import { useEffect, useState, useRef, useCallback, useMemo } from "react";
import {
  getDatabase,
  ref,
  onValue,
  off,
  get,
  DataSnapshot,
} from "firebase/database";
interface UseFirebaseOptions {
  debounceMs?: number;
  cacheTimeMs?: number;
  maxCacheSize?: number;
  enableLogging?: boolean;
}
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  path: string;
} // Global cache to share data across components const firebaseCache = new Map<string, CacheEntry<any>>(); export const useOptimizedFirebase = <T = any>( path: string, options: UseFirebaseOptions = {} ) => { const { debounceMs = 500, cacheTimeMs = 30000, // 30 seconds cache maxCacheSize = 100, enableLogging = false } = options; const [data, setData] = useState<T | null>(null); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const debounceTimer = useRef<NodeJS.Timeout>(); const unsubscribeRef = useRef<(() => void) | null>(null); const lastFetchTime = useRef<number>(0); // Check cache first const getCachedData = useCallback((path: string): T | null => { const cached = firebaseCache.get(path); if (cached && Date.now() - cached.timestamp < cacheTimeMs) { if (enableLogging) { console.log(`[PACKAGE] Cache hit for ${path}`); } return cached.data; } return null; }, [cacheTimeMs, enableLogging]); // Set cache data const setCacheData = useCallback((path: string, data: T) => { // Clean cache if it's getting too large if (firebaseCache.size >= maxCacheSize) { const oldestKey = Array.from(firebaseCache.keys())[0]; firebaseCache.delete(oldestKey); } firebaseCache.set(path, { data, timestamp: Date.now(), path }); if (enableLogging) { console.log(` Cached data for ${path}`); } }, [maxCacheSize, enableLogging]); // Debounced data update const debouncedSetData = useCallback((newData: T) => { if (debounceTimer.current) { clearTimeout(debounceTimer.current); } debounceTimer.current = setTimeout(() => { setData(newData); setCacheData(path, newData); setLoading(false); lastFetchTime.current = Date.now(); }, debounceMs); }, [debounceMs, setCacheData, path]); // Firebase subscription with optimizations const setupFirebaseListener = useCallback(async () => { if (!path) return; // Check cache first const cached = getCachedData(path); if (cached) { setData(cached); setLoading(false); return; } // Rate limiting - don't fetch too frequently const now = Date.now(); if (now - lastFetchTime.current < 1000) { // 1 second minimum if (enableLogging) { console.log(`⏰ Rate limiting Firebase call for ${path}`); } return; } try { const database = getDatabase(); const dataRef = ref(database, path); // Clean up previous listener if (unsubscribeRef.current) { unsubscribeRef.current(); } // Set up new listener with error handling const unsubscribe = onValue( dataRef, (snapshot: DataSnapshot) => { const value = snapshot.val(); if (value !== null) { debouncedSetData(value); setError(null); } else { setData(null); setLoading(false); } }, (error) => { console.error(`[FIRE] Firebase error for ${path}:`, error); setError(error.message); setLoading(false); } ); unsubscribeRef.current = () => off(dataRef); if (enableLogging) { console.log(`[FIRE] Firebase listener setup for ${path}`); } } catch (err) { console.error(`[FIRE] Firebase setup error for ${path}:`, err); setError(err instanceof Error ? err.message : 'Unknown error'); setLoading(false); } }, [path, getCachedData, debouncedSetData, enableLogging]); // One-time fetch (for non-real-time data) const fetchOnce = useCallback(async (): Promise<T | null> => { if (!path) return null; const cached = getCachedData(path); if (cached) return cached; try { const database = getDatabase(); const dataRef = ref(database, path); const snapshot = await get(dataRef); const value = snapshot.val(); if (value !== null) { setCacheData(path, value); } return value; } catch (err) { console.error(`[FIRE] Firebase fetch error for ${path}:`, err); throw err; } }, [path, getCachedData, setCacheData]); // Setup effect useEffect(() => { setupFirebaseListener(); return () => { // Cleanup if (unsubscribeRef.current) { unsubscribeRef.current(); } if (debounceTimer.current) { clearTimeout(debounceTimer.current); } }; }, [setupFirebaseListener]); // Memoized return value to prevent unnecessary re-renders const returnValue = useMemo(() => ({ data, loading, error, fetchOnce, refresh: setupFirebaseListener }), [data, loading, error, fetchOnce, setupFirebaseListener]); return returnValue; }; // Hook for batch Firebase operations export const useFirebaseBatch = () => { const [operations, setOperations] = useState<Array<() => Promise<any>>>([]); const [executing, setExecuting] = useState(false); const addOperation = useCallback((operation: () => Promise<any>) => { setOperations(prev => [...prev, operation]); }, []); const executeBatch = useCallback(async () => { if (operations.length === 0 || executing) return; setExecuting(true); const results = []; try { // Execute all operations in parallel for better performance const promises = operations.map(op => op()); const batchResults = await Promise.allSettled(promises); results.push(...batchResults); setOperations([]); // Clear operations after execution } finally { setExecuting(false); } return results; }, [operations, executing]); return { addOperation, executeBatch, operationCount: operations.length, executing }; };
